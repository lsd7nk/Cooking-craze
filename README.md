# Cooking-craze

## 1. Какие недостатки и недоработки вам удалось найти?

### 1.1 Использование строки в роли идентификатора

Это менее надёжно, т.к. строковые значения подвержены опечаткам и сложнее проверяются на этапе компиляции.   
Более надёжный подход — использовать числовой идентификатор (`int`) или перечисление (`enum : int`) - код более наглядный и безопасный.

### 1.2 Злоупотребление `foreach`

- `foreach` на 5-15% медленнее чем `for`, т.к работает с `IEnumerator`(`MoveNext(),` `Current`, `Dispose()`), а `for` работает с арифметикой индексов
- дополнительная аллокация(stack frame или heap - зависит уже от типа)

### 1.3 Злоупотребление `List`

В прототипе в больших кол-вах юзается `List`, заместо `array`, с этим связаны некоторые проблемы:

- у `List` доступ по индексу медленнее чем у `array`(не всегда, т.к доступ по индексу обычно инлайнируется компилятором, но опять же - не всегда)
- Создание `List` без capacity - возможные излишки аллоцируемой памяти, а также ресайзы внутреннего массива

### 1.4 Ненужные проверки объектов наследующих от `UnityEngine.Object` на null

Проверка на null сама по себе не перформит по производительности.   
Но проверка `UnityEngine.Object` на null затратнее из-за того, что `UnityEngine.Object` переопределяет оператор ==/!=.   
Это и добавляет дополнительную стоимость проверки - дополнительные внутренние проверки(вызовы в движок).

### 1.5 Нарушение инкапсуляции

В прототипе во многих компонентах программы нарушена инкапсуляция - публичные поля в `: MonoBehaviour` компонентах - это дает возможность менять извне ссылки без контроля.   
Пути решения проблемы:

- Если в доступе извне нет необходимости: приватное поле + сериализация в инспекторе с помощью атрибута `[SerializeField]`
- Если в доступе извне есть необходимость: свойство с публичным геттером и приватным сеттером + сериализация в инспекторе с помощью `[field: SerializeField]`

### 1.6 Странный механизм подписок в UI компонентах

Подписка происходит в момент вызова `Init()`, который в свою очередь вызывается при `!_isInit` в методе `Show()`.   
При этом: отписка не осуществляется, `_isInit = true` не присутствует.   

Это небезопасно, более надежно в этом случае использовать механизм отписок/подписок в `OnEnable()`/`OnDisable()`.

### 1.7 Инициализация компонентов объекта при объявлении дефолтными значениями

Это не то чтобы проблема вообще, просто мелкий недочет.   
Нет необходимости инициализировать какой-либо компонент объекта дефолтным значением.   
Пример:
```csharp
bool _isInit = false;
public Image GoalBar = null;
```

### 1.8 Табуляция, лишние пробелы

Это по большей части относится к code style, который во многих компаниях отличается, но на мой взгляд очень много лишних пробелов в проекте.
Примеры:
```csharp
public Image    GoalBar      = null;

public void Show() {
  if ( !_isInit ) {
				Init();
  }

  // ...
}
```

### 1.9 Интерполяция строк

В прототипе встречается следующая конструкция:
```csharp
GoalText.text = $"{gc.TotalOrdersServed}/{gc.OrdersTarget}";
```

- Интерполяция строк в этом случае аллоцирует managed-strings - это нагрузка на GC
- Метод `.SetText()` у `Tmp_Text`(особенно перегрузки, принимающие числовые типы) форматирует прям во внутренний буфер и обычно не аллоцирует managed-strings

Но важно избегать вызовы `.SetText()` с `params object[]` или с boxed значениями/лямбдами, это может привести к аллокациям.

### 1.10 `GetComponent`

В прототипе есть вызовы `GetComponent`, которые можно избежать с помощью сериализация поля в инспекторе.   
Пример(форматирование с прототипа сохранил):
```csharp
using UnityEngine;

using CookingPrototype.Controllers;

using JetBrains.Annotations;

namespace CookingPrototype.Kitchen {
	[RequireComponent(typeof(OrderPlace))]
	public sealed class OrderServer : MonoBehaviour {
		// OrderPlace _orderPlace; // было
    [SerializeField] private OrderPlace _orderPlace; // стало

		/*void Start() {
			_orderPlace = GetComponent<OrderPlace>();
		}*/ // было

		// ... 
		}
	}
}

```

### 1.11 Многочисленное использование LinQ

В прототипе в больших кол-вах используется LinQ, хотя везде его использования можно легко избежать.   
Использование LinQ часто создаёт промежуточные объекты/итераторы и выделяет делегаты — частая причина GC-скачков.   
В большинстве случаев безопаснее писать простые циклы и/или использовать структуры данных с быстрым `Contains`.   

Тот же самый вызов `someList.AsReadOnly()` можно заменить на использование массива и `ReadOnlySpan<T>`(это само собой тоже накладывает определенные ограничения).   
Это быстрый доступ без аллокаций, чем `someList.AsReadOnly()` похвастаться не может.   
Пример(форматирование с прототипа сохранил, понятно, что это изменение повлечет за собой другие, но это просто пример для наглядности):
```csharp
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace CookingPrototype.Kitchen {
	public sealed class Order {
		public class OrderFood {
			public string Name  { get; } = null;
			public string Needs { get; } = null;

			public OrderFood(string name, string needs) {
				Name  = name;
				Needs = needs;
			}
		}

		public readonly string               Name;
		// public ReadOnlyCollection<OrderFood> Foods { get { return _foods.AsReadOnly(); } } // было

		// List<OrderFood> _foods; // было
		readonly OrderFood[] _foods; // стало

		// public Order(string name, List<OrderFood> foods) { // было
		public Order(string name, OrderFood[] foods) { // стало
			Name   = name;
			_foods = foods;
		}
		
		public ReadOnlySpan<OrderFood> GetFoods() { // стало
			return _foods.AsSpan();
        }
	}
}

```

### 1.12 Неявные проверки ссылок на null

Мне кажется, лучше явно проверять ссылки на null потому что это даёт предсказуемое, безопасное и понятное поведение.
Пример:
```csharp
  public void Free() {
    // if ( !CurCustomer ) { // было
    if (CurCustomer == null) { // стало
        return;
    }
    var customer = CurCustomer;
    CurCustomer = null;
    Destroy(customer.gameObject);
}
```

## 2. Какие решения вы считаете сомнительными или нежелательными в более крупных проектах(и почему)?

### 2.1 Singleton

В прототипе, который я получил базовая архитектура проекта строится на паттерне Singleton, мне кажется такой подход весьма устаревшим и сомнительным и вот почему:
- Связность - очень высокая, каждый класс напрямую зависит от глобального состояния
- Тестируемость - достаточно плохая(то есть относительно трудно такое тестировать), т.к. сложно подменить зависимость на фейковую
- Масштабируемость - если в прототипе это не критично, то при росте проекта масштабируемость сразу падает
- Переиспользование кода - затруднительно, т.к. компоненты программы привязаны к конкретной реализации

Мне кажется, что при работе в команде и масштабируемости проекта, использование этого паттерна в контексте базовой архитектуры проекта создает следующие проблемы:
- хаос в зависимостях
- сложность в тестировании
- сложность в самой масштабируемости
- скорость разработки


### 2.2 Обычные делегаты

В прототипе очень часто встречается использование обычных с# делегатов и в этом, в целом, нет каких-то больших проблем, но если рассматривать какой-нибудь абстрактный "большой" проект, то можно наткнуться на некоторые проблемы:
- Отсутствие отписки: отсюда утечки памяти, null refs, висящие ссылки
- "Паутина" подписок: в большом проекте с десятком систем все превращается именно в это: "кто кого вызывает, где кто отписался, что триггерит что"

Мне кажется, в больших проектах можно использовать UniRx для решения выше описанных проблем:
- Автоматическое управление жизненным циклом с помощью `.AddTo(this);`
- Централизация потока данных

Также UniRx из под коробки имеет асинхронность, умеет работать с таймерами, задержками и временем - без корутин, что тоже является плюсом.
По сути своей делегаты - это единичные сигналы("вызвали -> сработало"), UniRx же позволяет работать с асинхронными потоками данных как с коллекциями - реагировать, фильтровать, комбинировать, буферизовать.

### 2.3 Таймеры/ожидание, Coroutines/UniTask

// to do: coroutines - fire & forget
// to do: uniTask - returned values & ...

## 3. Как можно было бы доработать прототип, чтобы улучшить его производительность на очень слабых мобильных устройствах, не жертвуя качеством картинки и без кардинальных изменений в коде или устройстве сцены?

### 3.1 Целевой framerate и синхронизация
- `Application.targetFrameRate = 30` для слабых устройств(или динамически задавать)
- В Player Settings отключить *VSync*(или настраивать в зависимости от устройства)

### 3.2 Использовать SpriteAtlas
- Android: *ETC2*(более старые) или *ASTC*(лучше качество/размер на современных), iOS: *ASTC*
- В Import Settings: *Compressor quality* = Normal/High
- *Generate Mip Maps* = включать только если нужно
- *Read/Write Enabled* = false
- Не использовать *Crunch* для runtime‑экономии VRAM(Crunch полезен только для download‑size, но может распаковываться в память)

### 3.3 Сборка и stripping
- Build: *IL2CPP*(мобильные сборки), strip engine code(*Managed Stripping Level* — Medium/High(тестировать))
- Включить *ARM64*(требование для iOS и многие Android store)

### 3.4 `Update()`
- Перенести действия из `Update()` в события, корутины, таймеры или реже вызываемые методы
- Или вместо множества объектов с `Update()` — централизованный менеджер/таймер, который вызывает нужные методы раз в N кадров

Желательно вообще избегать любой логики в `Update()`, т.к. в большинстве случаев можно обойтись без эиспользования этого метода

### 3.5 Runtime GC‑аллокации
- Избегать LINQ
- По возиожности стараться избегать больших runtime аллокаций
- Для временных данных использовать `Stack<T>` | `Span<T>`/`ReadOnlySpan<T>`

### 3.6 URP
- Перейти на URP при возможности

### 3.7 Физика
- Использовать простые коллайдеры(*Box*, *Circle*), они быстрее, чем *PolygonCollider*
- Можно также отключить ненужные физические слои через *Layer Collision Matrix*

### 3.8 Instantiate & Resources
- Избегать большого кол-ва `Instantiate()`, юзать `ObjectPool`
- Избегать частого использования `Resources.Load()`
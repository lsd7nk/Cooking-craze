# Cooking-craze

## 1. Какие недостатки и недоработки вам удалось найти?

### 1.1 Использование строки в роли идентификатора

Это менее надёжно, т.к. строковые значения подвержены опечаткам и сложнее проверяются на этапе компиляции.   
Более надёжный подход — использовать числовой идентификатор (`int`) или перечисление (`enum : int`) — код более наглядный и безопасный.

### 1.2 Злоупотребление `foreach`

- `foreach` на 5-15% медленнее, чем `for`, т.к. работает с `IEnumerator` (`MoveNext()`, `Current`, `Dispose()`), а `for` работает с арифметикой индексов
- дополнительная аллокация (stack frame или heap — зависит уже от типа)

Понятное дело, что это разница в "пределах шума" и узким моментом в производительности это не станет, но всё же это разница.

### 1.3 Злоупотребление `List`

В прототипе не так много мест, где нужна коллекция с плавающим размером.
Но `List` в большом количестве мест юзается заместо `array`, и с этим связаны некоторые проблемы:

- у `List` доступ по индексу медленнее, чем у `array` (не всегда, т.к. доступ по индексу обычно инлайнируется компилятором, но опять же — не всегда)
- Создание `List` без capacity — возможные излишки аллоцируемой памяти, а также ресайзы внутреннего массива

Узким местом в производительности приложения это стать вряд ли может.
Для статики — `array`, для динамики — `List` с заранее выставленной начальной ёмкостью.

### 1.4 Ненужные проверки объектов, наследующих от `UnityEngine.Object`, на null

Проверка на null сама по себе не перформит по производительности.   
Но проверка `UnityEngine.Object` на null затратнее из-за того, что `UnityEngine.Object` переопределяет оператор ==/!=.   
Это и добавляет дополнительную стоимость проверки — дополнительные внутренние проверки (вызовы в движок).

### 1.5 Нарушение инкапсуляции

В прототипе во многих компонентах программы нарушена инкапсуляция — публичные поля в `: MonoBehaviour` компонентах дают возможность менять извне ссылки без контроля.   
Пути решения проблемы:

- Если в доступе извне нет необходимости: приватное поле + сериализация в инспекторе с помощью атрибута `[SerializeField]`
- Если в доступе извне есть необходимость: свойство с публичным геттером и приватным сеттером + сериализация в инспекторе с помощью `[field: SerializeField]`

### 1.6 Странный механизм подписок в UI компонентах

Подписка происходит в момент вызова `Init()`, который, в свою очередь, вызывается при `!_isInit` в методе `Show()`.   
При этом отписка не осуществляется, `_isInit = true` в коде не встречается.   

Это небезопасно, более надёжно в этом случае использовать механизм отписок/подписок в `OnEnable()`/`OnDisable()`.

### 1.7 Инициализация компонентов объекта при объявлении дефолтными значениями

Это не то чтобы проблема вообще, просто мелкий недочёт.   
Нет необходимости инициализировать какой-либо компонент объекта дефолтным значением.   
Пример:
```csharp
bool _isInit = false;
public Image GoalBar = null;
```

### 1.8 Табуляция, лишние пробелы

Это по большей части относится к code style, который во многих компаниях отличается, но, на мой взгляд, в проекте очень много лишних пробелов.
Примеры:
```csharp
public Image    GoalBar      = null;

public void Show() {
  if ( !_isInit ) {
				Init();
  }

  // ...
}
```
Для решения проблемы можно использовать: Rider formatter | `.editorConfig` | Unity stylecop.

### 1.9 Интерполяция строк

В прототипе встречается следующая конструкция:
```csharp
GoalText.text = $"{gc.TotalOrdersServed}/{gc.OrdersTarget}";
```

- Интерполяция строк в этом случае аллоцирует managed-strings — это нагрузка на GC
- Метод `.SetText()` у `TMP_Text` (особенно перегрузки, принимающие числовые типы) форматирует прям во внутренний буфер и обычно не аллоцирует managed-strings

Но важно избегать вызовов `.SetText()` с `params object[]` или с boxed значениями/лямбдами — это может привести к аллокациям.

### 1.10 `GetComponent`

В прототипе есть вызовы `GetComponent`, которые можно избежать с помощью сериализации поля в инспекторе и последующего кэширования.   
Пример (форматирование с прототипа сохранил):
```csharp
using UnityEngine;

using CookingPrototype.Controllers;

using JetBrains.Annotations;

namespace CookingPrototype.Kitchen {
	[RequireComponent(typeof(OrderPlace))]
	public sealed class OrderServer : MonoBehaviour {
		// OrderPlace _orderPlace; // было
    [SerializeField] private OrderPlace _orderPlace; // стало

		/*void Start() {
			_orderPlace = GetComponent<OrderPlace>();
		}*/ // было

		// ... 
		}
	}
}

```

### 1.11 Многочисленное использование LinQ

В прототипе в больших количествах используется LinQ, хотя везде его использование можно легко избежать.   
Использование LinQ часто создаёт промежуточные объекты/итераторы и выделяет делегаты — частая причина GC-скачков.   
В большинстве случаев безопаснее писать простые циклы и/или использовать структуры данных с быстрым `Contains`.   

Тот же самый вызов `someList.AsReadOnly()` можно заменить на использование массива и `ReadOnlySpan<T>` (это, само собой, тоже накладывает определённые ограничения).   
Это более быстрый доступ без аллокаций, чем тот, которым `someList.AsReadOnly()` похвастаться не может.   
Пример (форматирование с прототипа сохранил; понятно, что это изменение повлечёт за собой другие, но это просто пример для наглядности):
```csharp
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace CookingPrototype.Kitchen {
	public sealed class Order {
		public class OrderFood {
			public string Name  { get; } = null;
			public string Needs { get; } = null;

			public OrderFood(string name, string needs) {
				Name  = name;
				Needs = needs;
			}
		}

		public readonly string               Name;
		// public ReadOnlyCollection<OrderFood> Foods { get { return _foods.AsReadOnly(); } } // было

		// List<OrderFood> _foods; // было
		readonly OrderFood[] _foods; // стало

		// public Order(string name, List<OrderFood> foods) { // было
		public Order(string name, OrderFood[] foods) { // стало
			Name   = name;
			_foods = foods;
		}
		
		public ReadOnlySpan<OrderFood> GetFoods() { // стало
			return _foods.AsSpan();
        }
	}
}

```

### 1.12 Неявные проверки ссылок на null

Мне кажется, лучше явно проверять ссылки на null, потому что это даёт предсказуемое, безопасное и понятное поведение.
Пример:
```csharp
  public void Free() {
    // if ( !CurCustomer ) { // было
    if (CurCustomer == null) { // стало
        return;
    }
    var customer = CurCustomer;
    CurCustomer = null;
    Destroy(customer.gameObject);
}
```

## 2. Какие решения вы считаете сомнительными или нежелательными в более крупных проектах (и почему)?

### 2.1 Singleton

В прототипе, который я получил, базовая архитектура проекта строится на паттерне Singleton, и мне кажется, такой подход весьма устаревшим и сомнительным — вот почему:
- Связность — очень высокая, каждый класс напрямую зависит от глобального состояния
- Тестируемость — достаточно плохая (то есть относительно трудно такое тестировать), т.к. сложно подменить зависимость на фейковую
- Масштабируемость — если в прототипе это не критично, то при росте проекта масштабируемость сразу падает
- Переиспользование кода — затруднительно, т.к. компоненты программы привязаны к конкретной реализации

Мне кажется, что при работе в команде и масштабируемости проекта использование этого паттерна в контексте базовой архитектуры проекта создаёт следующие проблемы:
- хаос в зависимостях
- сложность в тестировании
- сложность в самой масштабируемости
- скорость разработки

Статику лучше держать только для нижнего уровня (Utility/Logger), а хорошими альтернативами для базовой архитектуры проекта могут послужить:
- лёгкие контейнеры (VContainer)
- ScriptableObject-based сервис-локатор
- ECS

### 2.2 Обычные делегаты

В прототипе очень часто встречается использование обычных C# делегатов, и в этом, в целом, нет каких-то больших проблем, но если рассматривать какой-нибудь абстрактный "большой" проект, то можно наткнуться на некоторые сложности:
- Отсутствие отписки: отсюда утечки памяти, null refs, висящие ссылки
- "Паутина" подписок: в большом проекте с десятком систем всё превращается именно в это: "кто кого вызывает, где кто отписался, что триггерит что"

Мне кажется, в больших проектах можно использовать UniRx для решения вышеописанных проблем:
- Автоматическое управление жизненным циклом с помощью `.AddTo(this);`
- Централизация потока данных

Также UniRx из коробки имеет асинхронность, умеет работать с таймерами, задержками и временем — без корутин, что тоже является плюсом.
По сути своей делегаты — это единичные сигналы ("вызвали -> сработало"), UniRx же позволяет работать с асинхронными потоками данных как с коллекциями — реагировать, фильтровать, комбинировать, буферизовать.

### 2.3 Таймеры/ожидание, Coroutines/UniTask

// to do: coroutines - fire & forget
// to do: uniTask - returned values & ...

## 3. Как можно было бы доработать прототип, чтобы улучшить его производительность на очень слабых мобильных устройствах, не жертвуя качеством картинки и без кардинальных изменений в коде или устройстве сцены?

### 3.1 Целевой framerate и синхронизация
- `Application.targetFrameRate = 30` для слабых устройств (или задавать динамически)
- В Player Settings отключить *VSync* (или настраивать в зависимости от устройства)

`QualitySettings.vSyncCount` нужно обнулять, иначе `targetFrameRate` игнорируется.

### 3.2 Использовать SpriteAtlas
- Android: *ETC2* (более старые) или *ASTC* (лучше качество/размер на современных), iOS: *ASTC*
- В Import Settings: *Compressor quality* = Normal/High
- *Generate Mip Maps* = включать только если нужно
- *Read/Write Enabled* = false
- Не использовать *Crunch* для runtime‑экономии VRAM (Crunch полезен только для download‑size, но может распаковываться в память)

### 3.3 Сборка и stripping
- Build: *IL2CPP* (мобильные сборки), strip engine code (*Managed Stripping Level* — Medium/High, тестировать)
- Включить *ARM64* (требование для iOS и многих Android store)

### 3.4 `Update()`
- Перенести действия из `Update()` в события, корутины, таймеры или реже вызываемые методы
- Или вместо множества объектов с `Update()` — централизованный менеджер/таймер, который вызывает нужные методы раз в N кадров

Желательно вообще избегать любой логики в `Update()`, т.к. в большинстве случаев можно обойтись без использования этого метода

### 3.5 Runtime GC‑аллокации
- Избегать LINQ
- По возможности стараться избегать больших runtime-аллокаций
- Для временных данных использовать `Stack<T>` | `Span<T>`/`ReadOnlySpan<T>` (нельзя капсулировать в поля)

### 3.6 URP
- Перейти на URP при возможности

### 3.7 Физика
- Использовать простые коллайдеры (*Box*, *Circle*), они быстрее, чем *PolygonCollider*
- Можно также отключить ненужные физические слои через *Layer Collision Matrix*
- Можно отключить `Physics.autoSyncTransforms`

### 3.8 Instantiate & Resources
- Избегать большого количества `Instantiate()`, юзать `ObjectPool`
- Избегать частого использования `Resources.Load()`

### 3.9 Raycast targets
- Можно отключить ненужные `RaycastTarget` на соответствующих UI элементах

## 4. Что нужно сделать, если будет необходимость реализовать в рамках этого прототипа ещё одно блюдо (луковые кольца, жареные во фритюре) с новой механикой?

1. Добавить в проект спрайты луковых колец
2. Добавить префаб для заказа
3. Немного пересмотреть расположение инструментов на столе (UI)
4. Добавить фритюрницу на стол, на один из дочерних объектов накинуть (допустим, с именем "Placer"):
	- `FoodPlacer`
	- `Collider`
	- `EventTrigger`
5. Дальше создать ещё один дочерний объект (к объекту из пункта 4) и добавить 3 дочерних объекта, на которых (на каждом) будут:
	- `FoodPlace`
	- `FoodTransfer`
6. Возвращаемся к объекту "Placer" (из пункта 4) и в `FoodPlacer`, в сериализованное поле `Places`, прокидываем `FoodPlace` с трёх дочерних объектов из предыдущего пункта (5)
7. На объекте "Placer" (из пункта 4) на `EventTrigger` создаём новый *event type* — OnPointerDown, и дальнейшие действия зависят от возможной реализации:
	- Можно написать метод `TryPlaceAllFood()` у `FoodPlacer`: будет пробег по листу и вызов метода `TryPlaceFood` у каждого `FoodPlace`
	- Можно накинуть три *event* и в каждый из них прокинуть вызов `TryPlaceFood(AbstractFoodPlace place)` у определённого `FoodPlace` (из пункта 5)
8. Создаём объект "Plate" и создаём дочерние объекты — 3 штуки, на которых (на каждом) будут:
	- `OrderPlace`
	- `OrderPresenter`
	- `OrderServer`
	- `Collider`
	- `EventTrigger`
9. На каждом из трёх `EventTrigger` (из пункта 8) создаём новый *event type* — OnPointerUp и прокидываем туда `OrderServer.TryServeOrder` (тоже из пункта 8)
10. Прокинуть в `FoodTransfer`, в поле `DestPlaces` каждого дочернего объекта (из пункта 5), `OrderPlace` всех трёх объектов
11. Возвращаемся к `EventTrigger` (из пункта 4), создаём новый *event type* — OnPointerUp и прокидываем туда три `FoodTransfer` (из пункта 5), метод — `TryTransferFood`

Я перечислил основные шаги, с которыми придётся столкнуться для добавления нового блюда.   
Старался по минимуму менять кодовую базу проекта, т.к. зачастую в крупных проектах(и/или которые давно находятся в продакшене) сильно менять кодовую базу - нерационально с точки бизнеса.   
Обычно значительные изменения в кодовую базу можно вносить в рамках задачи на рефакторинг.
